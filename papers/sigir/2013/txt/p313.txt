Improve Collaborative Filtering

Through Bordered Block Diagonal Form Matrices

Yongfeng Zhang, Min Zhang, Yiqun Liu, Shaoping Ma

State Key Laboratory of Intelligent Technology and Systems

Department of Computer Science & Technology, Tsinghua University, Beijing, 100084, China

Tsinghua National Laboratory for Information Science and Technology
zhangyf07@gmail.com {z-m,yiqunliu,msp}@tsinghua.edu.cn

ABSTRACT

Collaborative Filtering-based recommendation algorithms have
achieved widespread success on the Web, but little work has
been performed to investigate appropriate user-item rela-
tionship structures of rating matrices. This paper presents
a novel and general collaborative ﬁltering framework based
on (Approximate) Bordered Block Diagonal Form structure
of user-item rating matrices. We show formally that matri-
ces in (A)BBDF structures correspond to community detec-
tion on the corresponding bipartite graphs, and they reveal
relationships among users and items intuitionally in recom-
mendation tasks. By this framework, general and special
interests of a user are distinguished, which helps to improve
prediction accuracy in collaborative ﬁltering tasks. Exper-
imental results on four real-world datasets, including the
Yahoo! Music dataset, which is currently the largest, show
that the proposed framework helps many traditional collab-
orative ﬁltering algorithms, such as User-based, Item-based,
SVD and NMF approaches, to make more accurate rating
predictions. Moreover, by leveraging smaller and denser sub-
matrices to make predictions, this framework contributes to
the scalability of recommender systems.

Categories and Subject Descriptors

H.3.3 [Information Storage and Retrieval]: Information
Filtering; H.3.5 [Online Information Services]: Web-
based services

Keywords

Collaborative Filtering; Community Detection; Block Diag-
onal Form; Graph Partitioning

1.

INTRODUCTION

Recommender Systems play an important role on the Web
which is becoming more and more personalized. With their
ability to discover various items of potential interest to users,
recommender systems beneﬁt users by saving time when the

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
SIGIR’13, July 28–August 1, 2013, Dublin, Ireland.
Copyright 2013 ACM 978-1-4503-2034-4/13/07 ...$15.00.

users are looking for what they want, and they beneﬁt online
shops that seek to expand their marketing eﬀorts.

Collaborative Filtering (CF) [22] recommendation algo-
rithms based on user-item rating matrices have achieved
great success in recommender systems. Typically, they take
a rating matrix (Figure 1(a)) as input to make rating predic-
tions, where each row/column/cross represents a user/item/
rating. An important advantage of CF-based algorithms is
their ability to make recommendations without clear con-
tent descriptions of the items, which is the reason why they
are widely applied in recommender systems thus far [22].

However, CF-based recommendation algorithms also suf-
fer from several drawbacks. First is the data sparsity prob-
lem, which usually decreases the accuracy of the rating pre-
dictions. Second is the problem of scalability, which is usu-
ally caused by the presence of computationally expensive
training components. Finally, the lack of distinguishing
users and items from diﬀerent communities, which makes
them incapable of detecting users’ special interests and de-
creases their abilities to make long tail recommendations.

Some previous research has been performed attempting
to address these problems, which mainly focus on various
matrix-clustering [11, 26, 27, 39, 34] or community detection
[6, 36, 23] techniques. Clustering-based approaches cluster
users and/or items for CF. However, in real-world applica-
tions, clusters are usually diﬃcult to interpret. Moreover,
they usually assume that a user or an item should fall into
one particular cluster, which might not be a reasonable as-
sumption in reality. Community detection approaches based
on user-item bipartite graphs attempt to improve accuracy
and diversity by detecting user-item communities. Distin-
guishing the general and special interests of a given user
helps to make better recommendations, but it is diﬃcult for
them to take advantage of various successful CF techniques
on rating matrices in real-world recommender systems.

In fact, rating matrices and bipartite graphs can be equiv-
alently transformed into each other. Before problem for-
malization, we would like to use an intuitional example to
introduce the matrix structures that are leveraged in this
framework. Figure 1(a) shows a rating matrix, and its corre-
sponding bipartite graph is shown in Figure 1(d), where each
row/column/non-zero of the matrix is represented as an R-
node/C-node/Edge in the graph. Figure 1(b) is a Bordered
Block Diagonal Form (BBDF) structure of the original ma-
trix, where Row4, Row9 and Column7 are permuted to ‘bor-
ders’, and the remaining parts are thus permuted into two
‘diagonal blocks’. The permuting procedure is conducted
recursively on the ﬁrst diagonal block. The Approximate

313(cid:3)
(cid:4)
(cid:5)
(cid:6)
(cid:7)
(cid:8)
(cid:9)
(cid:10)
(cid:11)

(cid:5)(cid:1)(cid:1)(cid:1)(cid:6)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:7)(cid:1)(cid:1)(cid:1)(cid:8)(cid:1)(cid:1)(cid:1)(cid:1)(cid:9)(cid:1)(cid:1)(cid:1)(cid:1)(cid:10)(cid:1)(cid:1)(cid:1)(cid:1)(cid:11)(cid:1)(cid:1)(cid:1)(cid:12)(cid:1)(cid:1)(cid:1)(cid:1)(cid:13)(cid:1)(cid:1)(cid:5)(cid:4)(cid:1)(cid:1)(cid:5)(cid:5)(cid:1)
(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(a) Original Matrix

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:4)
(cid:9)
(cid:7)
(cid:3)
(cid:5)
(cid:10)
(cid:8)
(cid:6)
(cid:11)

(cid:12)(cid:1)(cid:1)(cid:1)(cid:1)(cid:7)(cid:1)(cid:1)(cid:1)(cid:10)(cid:1)(cid:1)(cid:1)(cid:1)(cid:8)(cid:1)(cid:1)(cid:1)(cid:5)(cid:5)(cid:1)(cid:1)(cid:6)(cid:1)(cid:1)(cid:1)(cid:1)(cid:13)(cid:1)(cid:1)(cid:1)(cid:5)(cid:1)(cid:1)(cid:1)(cid:5)(cid:4)(cid:1)(cid:1)(cid:1)(cid:9)(cid:1)(cid:1)(cid:1)(cid:11)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)
(b) BBDF matrix

(cid:2)(cid:1)

(cid:12)(cid:1)(cid:1)(cid:1)(cid:7)(cid:1)(cid:1)(cid:1)(cid:1)(cid:10)(cid:1)(cid:1)(cid:1)(cid:1)(cid:8)(cid:1)(cid:1)(cid:1)(cid:5)(cid:5)(cid:1)(cid:1)(cid:11)(cid:1)(cid:1)(cid:1)(cid:1)(cid:6)(cid:1)(cid:1)(cid:1)(cid:13)(cid:1)(cid:1)(cid:1)(cid:1)(cid:5)(cid:1)(cid:1)(cid:1)(cid:5)(cid:4)(cid:1)(cid:1)(cid:1)(cid:9)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1) (cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:4)
(cid:9)
(cid:7)
(cid:3)
(cid:6)
(cid:5)
(cid:10)
(cid:8)
(cid:11)

(c) ABBDF matrix

(cid:2)(cid:6)(cid:1)
(cid:2)(cid:7)(cid:1)
(cid:2)(cid:8)(cid:1)
(cid:2)(cid:9)(cid:1)
(cid:2)(cid:10)(cid:1)
(cid:2)(cid:11)(cid:1)
(cid:2)(cid:12)(cid:1)
(cid:2)(cid:13)(cid:1)
(cid:2)(cid:14)(cid:1)

(cid:1)(cid:6)(cid:1)
(cid:1)(cid:7)(cid:1)
(cid:1)(cid:8)(cid:1)
(cid:1)(cid:9)(cid:1)
(cid:1)(cid:10)(cid:1)
(cid:1)(cid:11)(cid:1)
(cid:1)(cid:12)(cid:1)
(cid:1)(cid:13)(cid:1)
(cid:1)(cid:14)(cid:1)
(cid:1)(cid:6)(cid:5)(cid:1)
(cid:1)(cid:6)(cid:6)(cid:1)

(cid:1)(cid:13)(cid:1)

(cid:2)(cid:7)(cid:1)

(cid:2)(cid:12)(cid:1)

(cid:1)(cid:11)(cid:1)

(cid:1)(cid:8)(cid:1)

(cid:2)(cid:8)(cid:1)

(cid:1)(cid:14)(cid:1)

(cid:1)(cid:7)(cid:1)

(cid:2)(cid:6)(cid:1)

(cid:1)(cid:9)(cid:1)

(cid:1)(cid:6)(cid:6)(cid:1)

(cid:2)(cid:10)(cid:1)

(cid:2)(cid:9)(cid:1)

(cid:2)(cid:14)(cid:1)

(cid:1)(cid:12)(cid:1)

(cid:2)(cid:11)(cid:1)

(cid:1)(cid:6)(cid:1)

(cid:1)(cid:6)(cid:5)(cid:1)

(cid:1)(cid:10)(cid:1)

(cid:2)(cid:13)(cid:1)

(cid:1)(cid:13)(cid:1)

(cid:2)(cid:12)(cid:1)

(cid:1)(cid:11)(cid:1)

(cid:1)(cid:8)(cid:1)

(cid:2)(cid:7)(cid:1)

(cid:2)(cid:8)(cid:1)

(cid:1)(cid:14)(cid:1)

(cid:1)(cid:7)(cid:1)

(cid:2)(cid:9)(cid:1)

(cid:2)(cid:6)(cid:1)

(cid:1)(cid:6)(cid:6)(cid:1)

(cid:1)(cid:12)(cid:1)

(cid:1)(cid:9)(cid:1)

(cid:2)(cid:10)(cid:1)

(cid:1)(cid:6)(cid:5)(cid:1)

(cid:2)(cid:11)(cid:1)

(cid:1)(cid:10)(cid:1)

(cid:2)(cid:14)(cid:1)

(cid:1)(cid:6)(cid:1)

(cid:2)(cid:13)(cid:1)

(d) Original Graph

(e) BBDF Graph

(f) ABBDF Graph

Figure 1: An example of User-Item Rating Matrices and their corresponding Bipartite Graphs.

Bordered Block Diagonal Form (ABBDF) structure is a gen-
eralization of BBDF where scattered non-zeros are allowed
in oﬀ-diagonal blank areas, as shown in Figure 1(c).

It is important to note that the ABBDF structure of rat-
ing matrices is capable of representing community detection
results on the corresponding bipartite graphs.
In Figure
1(f), for example, each community in the graph corresponds
to a diagonal block in Figure 1(c); nodes out of communi-
ties constitute borders, and dotted inter-community edges
correspond to the non-zeros in oﬀ-diagonal blank areas. In
this sense, BBDF structure is a special case of ABBDF when
the community detection result contains no inter-community
edge, as shown by the example in Figure 1(e) and 1(b).

The CF framework based on (A)BBDF structures of rat-
ing matrices proposed in this paper is capable of combining
the advantages of community detection and matrix cluster-
ing techniques as well as making use of various CF algo-
rithms. An important advantage of this framework is that
it does not rely on a speciﬁc CF algorithm. Any CF algo-
rithm that is based on rating matrices can be integrated into
this framework, such as User-based, Item-based, SVD and
NMF. Experimental results show that this framework helps
these CF algorithms to improve the prediction accuracy and,
at the same time, beneﬁts system scalability.

In summary, the contributions of the paper are four-fold:

• The relationship between (A)BBDF structures of rat-
ing matrices and community detection on the corre-
sponding bipartite graphs is investigated formally.

• Two density-based algorithms are designed to trans-
form sparse rating matrices into (A)BBDF structures.
• We propose a general collaborative ﬁltering framework
based on these structures to make rating predictions
in recommendation tasks.

• Both the eﬃciency and eﬀectiveness of the proposed
framework are veriﬁed through experimental studies
on four benchmark datasets.

In the remaining part of this paper, section 2 reviews some
related work, and section 3 introduces some deﬁnitions and

theorems. Section 4 presents the proposed algorithms and
framework. Experimental settings and results are shown in
section 5. In section 6, we present a discussion, and section
7 concludes the work and provides future directions.

2. RELATED WORK

Collaborative Filtering (CF) [22, 2] algorithms based on
user-item rating matrices focus on the core task of making
rating predictions. They attempt to discover and leverage
the knowledge of users’ preferences when making recommen-
dations. Unlike Content-Based Filtering (CBF) [28], which
makes recommendations by analyzing the item features of a
user’s historical items, CF algorithms take advantage of the
wisdom of crowds, and they usually have no special require-
ments on items or domains.

One of the most widely used forms of CF is the nearest
neighbor approach [22]. User-based [29] and Item-based [31]
CF algorithms are two best-known methods that fall into
this category. Nearest neighbors can be determined by var-
ious similarity measures, such as Pearson correlation and
cosine similarity. User-based CF attempts to ﬁnd the neigh-
borhood of like-minded users for each user and predicts a
user’s ratings according to the ratings given by the user’s
neighbors. Similarly, Item-based CF takes advantage of the
similar items of each item, and predictions for a user are de-
termined by the user’s historical ratings. Nearest neighbor
approaches are usually unable to detect item synonymies
and are also computationally expensive in real-world recom-
mender systems.

The Matrix Factorization (MF) [16] approaches attempt
to factorize a rating matrix into products of real-valued com-
ponent matrices. A reconstruction error objective function
is usually deﬁned, and gradient descent optimization proce-
dures are usually conducted [25]. SVD [33, 37] and NMF [17,
40, 19] methods are typical algorithms that are investigated.
However, computationally intensive training components of
these techniques make them not scalable enough and imprac-
tical to conduct frequent model re-training. Incremental and
distributed versions of SVD and NMF algorithms [4, 37, 32,
21, 10] partially alleviate this problem, but they are still not

314eﬃcient enough because the eﬀects of small updates to the
rating matrix are not localized.

Various matrix clustering techniques have been investi-
gated in an attempt to address the problems of eﬃciency,
scalability and sparsity. User clustering and item clustering
methods [26] cluster user or item vectors ﬁrst, and nearest
neighbors of a user or item are restricted to its cluster. Some
other matrix clustering techniques, such as co-clustering [7,
18, 11], ping-pang algorithm [27] and clustered low-rank ap-
proximation [35], cluster users and items at the same time,
and the procedure of rating prediction takes advantage of
these user-item clusters. By utilizing clusters, the scalabil-
ity of recommender systems is usually improved, but clus-
ters are usually diﬃcult to interpret.
In addition, these
approaches usually force a user or item to fall into a sin-
gle cluster, which might not be a reasonable assumption in
real-world applications.

Recently, community detection techniques based on graphs
have been investigated extensively with the rapid growth of
social networks [20, 24, 23, 6], which helps to improve both
the accuracy and diversity of the recommender systems by
extracting user or item communities.

In fact, user-item rating matrices can be equivalently trans-
formed into bipartite graphs [1, 3], and community detec-
tion results on the bipartite graphs can be represented as
(A)BBDF structures on the corresponding rating matrices.
Any CF method can still be applied to the permuted ma-
trix without any modiﬁcation, but by leveraging user-item
community information therein, more accurate and speciﬁc
recommendations can be made.

3. DEFINITIONS AND THEOREMS

Several deﬁnitions and theorems are presented in this sec-
tion, which will be the basis of the (A)BBDF permutation
algorithms and the collaborative ﬁltering framework to be
proposed in Section 4.

Definition 1. Bordered Block Diagonal Form (BBDF).

Matrix A is in Bordered Block Diagonal Form if:

A =



A11 A12 ··· A1k A1B
A21 A22 ··· A2k A2B
...
...
Ak1 Ak2 ··· Akk AkB
AB1 AB2 ··· ABk ABB

. . .

...

...



=



D1

D2

C1
C2
...
Dk Ck
R1 R2 ··· Rk B

. . .



(1)

Namely, Aij = 0 (i != j, 1 ≤ i, j ≤ k). Each Di (1 ≤
i ≤ k) is a ‘diagonal block’; R = [R1 ···R kB] and C =
1 ···C T
k BT ]T are ‘borders’. Recursively, each of the diag-
[C T
onal blocks Di can also be in the BBDF structure. !

BBDF structure is a generalization of Block Diagonal Form
(BDF) matrices, for example, A = diag(D1D2 ···D k), where
the latter has no border.

Definition 2. Approximate Bordered Block Diag-
onal Form (ABBDF). Matrix A is in Approximate Bor-
dered Block Diagonal Form if:

(a) Communities

(b) Middle result

(c) ABBDF

Figure 2: Community detection and ABBDF, k = 2

Namely, Aij (i != j, 1 ≤ i, j ≤ k) can also contain scattered
non-zeros compared with the BBDF structure. D1D2 ···D k
might also be in the ABBDF structure. !

ABBDF is a generalization of BBDF in that scattered
non-zeros are allowed in oﬀ-diagonal blank areas. We also
refer to BBDF as Accurate BBDF to distinguish it from
Approximate BBDF.

Definition 3. Community Detection. Given a graph
G = (V,E), a community in G is a set of vertices Ci ⊆V ,
and a community detection with k (k ≥ 1) communities is
C = {C1C2 ···Ck}, witch satisﬁes the following:

i. Ci != ∅ (1 ≤ i ≤ k)

ii. Ci ∩!

k"j=1,j!=iCj# != Ci (1 ≤ i ≤ k)

The second requirement means that each community con-
tains at least one monopolized node. It’s important to clarify
that no deﬁnition of community detection is universally ac-
cepted until now because deﬁnitions often depend on a spe-
ciﬁc application and algorithm [9]. This deﬁnition is solely
for introducing the relationships between the (A)BBDF struc-
ture and community detection in this paper. Even so, Def-
inition 3 is general enough to describe the output of many
frequently used community detection algorithms, including
both independent and overlapping communities, depending

on Ci ∩$"k

j=1,j!=i Cj% = ∅ (1 ≤ i ≤ k) or not.

Theorem 1. Any community detection result with k com-
munities C = {C1C2 ···Ck} on a bipartite graph G = (V,E)
can be represented as an ABBDF structure with k diagonal
blocks on its corresponding rating matrix A.

Proof. Without loss of generality, we assume that"k
community. Otherwise, we permute the nodes in V−"k

i=1 Ci =
V, in other words, that each node belongs to at least one
i=1 Ci
to the borders ﬁrst. We will make a proof by induction.
If k = 1, then the property holds naturally, and the matrix

is viewed as a single diagonal block.

If k = 2, then permute the nodes in S = C1∩C2 to borders,
followed by permuting the nodes in C"1 = C1 −S and C"2 =
C2 −S to construct two diagonal blocks, shown in Figure 2.
Suppose that the property holds for k = n − 1. When
i=2 Ci% and
k = n, as shown in Figure 3, let S1 = C1 ∩$"n
C"i = Ci −S 1 (1 ≤ i ≤ n). Note that C"i != ∅ (1 ≤ i ≤ n),

A =



A11 A12 ··· A1k A1B
A21 A22 ··· A2k A2B
...
...
Ak1 Ak2 ··· Akk AkB
AB1 AB2 ··· ABk ABB

. . .

...

...

=





D1 A12 ··· A1k C1
A21 D2 ··· A2k C2
...
...
Ak1 Ak2 ··· Dk Ck
R1 R2 ··· Rk B

. . .

...

...

(2)



Figure 3: Community detection and ABBDF, k = n

315according to Deﬁnition 3. Permute the vertices in S1 to the
borders, permute C"1 to the upper-left corner and permute
"n
i=2 C"i to the bottom-right corner. According to the induc-
tive assumption,"n
i=2 C"i can be permuted into an ABBDF
structure with n − 1 diagonal blocks in the same manner.
As a result, the ﬁnal matrix is an ABBDF structure with n
diagonal blocks, and the ﬁnal border is S ="n−1
It is helpful to look at the case of k = 3, as shown in Figure
4. First, let S1 = C1 ∩ (C2 ∪C 3) and C"i = Ci −S 1 (i = 1, 2, 3).
Permute S1 to the borders, and there will be two diagonal
blocks in the matrix, corresponding to vertex sets C"1 and
C"2 ∪C "3. Moreover, let S2 = C"2 ∩C "3 and C""i = C"i −S 2 (i =
2, 3). By recursively permuting S2 to the borders, one of the
diagonal blocks is again permuted into an ABBDF structure,
which gives us two new diagonal blocks that correspond to
C""2 and C""3 . The ﬁnal number of diagonal blocks is 3, and
the border is S = S1 ∪S 2.

i=1 Si.

Corollary 1. Given a community detection result C =
j=1,j!=i Cj%
{C1C2 ···Ck} on a bipartite graph, let Si = Ci∩$"k
and C"i = Ci −S i for each 1 ≤ i ≤ k. Then, C corresponds to
an Accurate BBDF structure if and only if there is no edge
from C"i to C"j when i != j.

Proof. The result follows from the fact that a non-zero
in the oﬀ-diagonal blank areas in an ABBDF structure cor-
responds to an edge that connects two nodes, u and v, from
two communities, C(u) and C(v), where u and v are monop-
olized by C(u) and C(v), correspondingly.

Intuitionally, a diagonal block in an (A)BBDF matrix is
a ‘user-item community’, with its users and items being its
‘dominant’ users and items. The borders can be viewed as
‘super’ users and items among communities. Super users are
users whose tastes are relatively broad and fall into diﬀerent
communities. Super items are items favored by users from
diﬀerent communities. Users might indeed focus their main
attentions on certain ﬁelds, but they do step into other ﬁelds
occasionally, which is important when detecting the poten-
tial interests of a user. In this sense, an Approximate BBDF
structure is more natural than an Accurate BBDF structure.
The following deﬁnitions and theorems concern how to
permute a sparse rating matrix into accurate and approxi-
mate BBDF structures.

Definition 4. Graph Partitioning by Vertex Sepa-

rator (GPVS)-based Community Detection.

Consider an undirected graph G = (V,E). Adj(v) denotes
the set of vertices adjacent to v. For a vertex subset V" ⊂V ,
Adj(V") = {vj ∈V −V " : ∃vi ∈V "s.t. vj ∈ Adj(vi)}.
VS ⊂V is a vertex separator if the subgraph induced by
V−V S has k ≥ 2 connected components. Formally, GPVS is
deﬁned as Γv = {V1V2 ···Vk;VS}, where Vi != ∅, Vi∩VS = ∅,

Figure 4: Community detection and ABBDF, k = 3

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:5)(cid:1)(cid:1)(cid:1)(cid:1)(cid:6)(cid:1)(cid:1)(cid:1)(cid:1)(cid:7)(cid:1)(cid:1)(cid:1)(cid:1)(cid:8)(cid:1)(cid:1)(cid:1)(cid:9)(cid:1)(cid:1)(cid:1)(cid:1)(cid:10)(cid:1)(cid:1)(cid:1)(cid:1)(cid:11)(cid:1)(cid:1)(cid:1)(cid:12)(cid:1)(cid:1)(cid:1)(cid:1)(cid:13)(cid:1)(cid:1)(cid:1)(cid:5)(cid:4)(cid:1)(cid:1)(cid:5)(cid:5)(cid:1)
(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1) (cid:2)(cid:1)

(cid:3)
(cid:4)
(cid:5)
(cid:6)
(cid:7)
(cid:8)
(cid:9)
(cid:10)
(cid:11)
(a) A block in matrix

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:3)
(cid:4)
(cid:5)
(cid:6)
(cid:7)
(cid:8)
(cid:9)
(cid:10)
(cid:11)

(cid:5)(cid:1)(cid:1)(cid:1)(cid:1)(cid:6)(cid:1)(cid:1)(cid:1)(cid:1)(cid:7)(cid:1)(cid:1)(cid:1)(cid:1)(cid:8)(cid:1)(cid:1)(cid:1)(cid:9)(cid:1)(cid:1)(cid:1)(cid:1)(cid:10)(cid:1)(cid:1)(cid:1)(cid:1)(cid:11)(cid:1)(cid:1)(cid:1)(cid:12)(cid:1)(cid:1)(cid:1)(cid:1)(cid:13)(cid:1)(cid:1)(cid:1)(cid:5)(cid:4)(cid:1)(cid:1)(cid:5)(cid:5)(cid:1)
(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

(b) Restricted lines

(cid:2)(cid:1)

(cid:2)(cid:1) (cid:2)(cid:1)

Figure 5: Block, Line and Line Density

i=1 Vi) ∪V S = V. Note that VS = ∅ is allowed.

Adj(Vi) ⊂V S for 1 ≤ i ≤ k, Vi ∩V j = ∅ for 1 ≤ i < j ≤ k,
and ("k
C = {C1C2 ···Ck} is the community detection result, where
Ci = Vi ∪V S (1 ≤ i ≤ k). !
Intuitively in GPVS, the removal of a vertex separator
splits the graph into k connected components. GPVS is a
type of community detection algorithm that corresponds to
accurate BBDF structures. This conclusion can be derived
directly from Corollary 1 and Deﬁnition 4 because Si = Ci ∩
when i != j.
The reader can refer to Figure 1(b) and 1(e) for an ex-
ample. By ﬁrst removing nodes R4 R9 and C7 which are
represented by shaded borders, the remaining nodes are par-
titioned into two parts, corresponding to the two main diag-
onal blocks in the rating matrix. Furthermore, by removing
nodes R3 C2 and C9, one of the diagonal blocks is again per-
muted into the BBDF structure with two diagonal blocks.

$"k
j=1,j!=i Cj% = VS and C"i = Ci −S i = Vi are disconnected

Definition 5. Graph Partitioning by Edge Separa-

tor (GPES)-based Community Detection.

Consider the undirected graph G = (V,E).
ES ⊂E is an edge separator if the removal of ES gives
Γe = {V1V2 ···Vk} (k ≥ 2), where Vi != ∅ for 1 ≤ i ≤ k,
Vi ∩V j = ∅ for 1 ≤ i < j ≤ k, "k
i=1 Vi = V, and the
subgraphs induced by Vi and Vj are disconnected for i != j.
C = {C1C2 ···Ck} is the community detection result, where
Ci = Vi (1 ≤ i ≤ k). !
GPES-based community detection corresponds to an ABBDF
structure with no border because Si = Ci ∩$"k

∅. This structure can be used to further construct an ABBDF
structure with borders when necessary, which will be pre-
sented by the algorithms in the following sections.

j=1,j!=i Cj% =

Definition 6. Density. Let A be an m × n (m, n ≥ 1)
matrix, let n(A) be the number of non-zeros in A, and let
area(A) = m × n be the area of A.
The density of A is ρ(A) = n(A)
area(A) , and the average den-
sity of k matrices A1 ···A k is ¯ρ(A1 ···A k) = !k
i=1 n(Ai)
i=1 area(Ai) .
!k
Let G denote the bipartite graph of A; then, ρ(G) = ρ(A),
¯ρ(G1 ···Gk) = ¯ρ(A1 ···A k).
A row or a column of matrix A is referred to as a ‘line’.
The density of line l restricted to a block B is ρ(l(B)), where
l(B) denotes the sub-vector on line l that is restricted to block
B, shown as the red dashed rectangles in Figure 5(b). !

The density of graphs or matrices has been widely used
in various community detection algorithms and tasks [9].
Taking Figure 5 as an example, the density of the shaded
block is 9
In Figure 5(b), the density of
column 5 is 5
9 , and the density of row 8 restricted to the
shaded block is 2
5 .

25 in Figure 5(a).

3164. ALGORITHMS
4.1 Accurate BBDF Permutation
4.1.1 Basic Procedure of BBDF Permutation
In accurate BBDF permutation, a basic procedure is per-
formed recursively, which is to permute some lines to borders
and to permute the remaining part to construct several diag-
onal blocks. This recursive framework is known as George’s
nested dissection approach [3, 14], which has been widely
used in ﬁll-reducing ordering of sparse matrices. This basic
procedure is investigated in this subsection, and the accu-
rate BBDF permutation algorithm in the following subsec-
tion leverages this procedure.

The basic step is equivalent to GPVS [1] on the corre-
sponding user-item bipartite graph, which has been shown
in preliminaries. It is typical that a graph has more than one
vertex separator, and a proper GPVS algorithm attempts
to ﬁnd the one with the least number of vertices, namely,
the minimum vertex separator. Unfortunately, the minimum
vertex cut problem is known to be NP-hard [5], but this
problem has been investigated extensively, and many eﬃ-
cient and high-quality heuristic-based methods have been
proposed [15], such as the multilevel approach, spectral par-
titioning and kernel-based methods.
It has been veriﬁed
both theoretically and experimentally that multilevel ap-
proaches usually provides both fast execution time and very
high quality partitions [15, 30, 1, 3]. Perhaps the most
widely known and used package for graph partitioning is
Metis by Karypis [13], which is based on a multilevel ap-
proach, and we chose the core multilevel graph partitioning
routine implemented in Metis as the basic GPVS algorithm.
In this study, we utilize the density of user-item communi-
ties to control the procedure of BBDF permutation because
dense subgraphs are usually interpreted as actual commu-
nities. This approach has been widely used in community
detection tasks [9]. Algorithm 1 shows the basic procedure.

Algorithm 1 Basic-BBDF-Permutation(A,G)
Require:

User-Item rating matrix A.
Bipartite graph G = (V,E) = (R∪C ,E) of A.  R/C
are row/column vertex sets of V correspondingly.
Average density of resulting diagonal blocks ¯ρ.

Ensure:

1:Γ v ←{V 1V2 ···Vk;VS}← GPVS(G)
2: Permute rows of A in order of R1R2 ···RkRS
3: Permute columns of A in order of C1C2 ···CkCS
4: return ¯ρ(D1D2 ···D k)  Di denotes the i-th diagonal

block which corresponds to vertex set Vi = Ri ∪C i
We expect the average density of diagonal blocks to be
improved compared with the density of the original matrix
A after permutation; we discuss the relevant issues here.

Taking the notations in Deﬁnition 6, we have:

ρ(A) =

n(A)

area(A)

,

¯ρ(D1 ···D k) = &k
&k

i=1 n(Di)

i=1 area(Di)

i=1 n(Di), n2 = n−n1; s = area(A),

Let n = n(A), n1 =&k
s1 =&k

i=1 area(Di), s2 = s − s1. We have:
1 = ¯ρ(D1 ···D k) =

ρA = ρ(A) =

n
s

,ρ

n1
s1

,ρ

2 =

n2
s2

where ρ2 represents the average density of oﬀ-diagonal
blank areas plus borders. Let ¯ρ(D1 ···D k) >ρ (A), namely,
ρ1 >ρ A; then, we have:
n1 + n2
s1 + s2 ⇔

n2
s2 ⇔ ρ1 >ρ 2

n1
s1

n1
s1

n
s

>

>

=

This statement means that the average density of the re-
sulting diagonal blocks will increase if and only if it is greater
than the average density of the remaining parts. This rela-
tionship is usually satisﬁed because the GPVS algorithm
attempts to ﬁnd a separator with the minimum number of
vertices. Furthermore, the total area of oﬀ-diagonal blocks
plus borders tends to be much larger than the area of the
diagonal blocks [1]. For this reason, we choose the average
density to be an important controller in the algorithm.
4.1.2 Accurate BBDF Permutation Algorithm
The density-based BBDF permutation algorithm requires
a parameter ρ as an input, which is a pre-deﬁned require-
ment on the minimum average density of diagonal blocks.
It conducts Basic-BBDF-Permutation on a matrix and re-
curses on each of the resulting diagonal blocks until the den-
sity of a diagonal block has reached the density requirement
ρ or the Basic-BBDF-Permutation cannot improve the av-
erage density any more. Algorithm 2 shows the procedure.

Algorithm 2 BBDF-Permutation(A,G,ρ )
Require:

User-Item rating matrix A.
Bipartite graph G = (V,E) of A.
Density requirement ρ.

Ensure:

Matrix A permuted into BBDF structure.

1: ρA ← ρ(A)
2: if ρA <ρ then
3:
4:
5:
6:

 else do nothing

¯ρ ← Basic-BBDF-Permutation(A,G)
if ¯ρ>ρ A then

 else do nothing
for each diagonal block Di in A do

BBDF-Permutation(Di,GVi ,ρ )  Vi denotes
the vertex set of Di, GVi is the subgraph induced by Vi

end for

7:
8:
9: end if

end if

Note that, in the 4-th line, we do nothing if the aver-
age density of the resulting diagonal blocks is not improved
compared with the original matrix, although some diagonals
might not have reached the density requirement ρ. Such a
diagonal D is viewed as a sparse user-item community, and
such a case occurs when the density requirement ρ is set
too high. An important reason for using the average density
to prevent such diagonals from recursion is that they would
result in many small scattered communities with only a few
users and items. Proper density requirements give better
BBDF structures, and this issue will be discussed with the
experimentation below.

4.2 Approximate BBDF Permutation

Approximate BBDF can be achieved by GPES, and we
also make use of the multilevel graph partitioning approach
that is implemented in Metis. The ABBDF permutation
algorithm also has a density requirement of ρ, as input. It
computes a GPES on the bipartite graph of a rating matrix

317A, and by ignoring the non-zeros corresponding to the edge
separator, matrix A is permuted to several diagonal blocks.

Unlike an accurate BBDF permutation, which accomplishes

nothing if the average density is not improved after the per-
mutation, the approximate BBDF permutation algorithm
moves lines from diagonal blocks to borders to further im-
prove their average density, unless the average density is
greater than the original matrix. Note that this goal can al-
ways be reached because the density of a single non-zero is
one. This procedure is performed recursively in each diago-
nal block until the density requirement is reached, as shown
in Algorithm 3.

Algorithm 3 ABBDF-Permutation(A,G,ρ )
Require:

User-Item rating matrix A.
Bipartite graph G = (V,E) = (R∪C ,E) of A.
Density requirement ρ.

Ensure:

Matrix A permuted into ABBDF structure.

return

1: if ρ(A) ≥ ρ then
2:
3: else
4:Γ
5:
6:
7:
8:
9:
10:
11: end if

end for

e ←{V 1V2 ···Vk}← GPES(G)
Permute rows of A in order of R1R2 ···Rk
Permute columns of A in order of C1C2 ···Ck
{V"1V"2 ···V"k;V"S}← Improve-Density(A,G, Γe)
for each diagonal block Di in A do
,ρ )

ABBDF-Permutation(Di,GV!i

The sub-procedure Improve-Density selects the speciﬁc
line whose removal improves the average density the most
from the diagonal blocks at each time and inserts it into the
borders. This process is shown in Algorithm 4.

Algorithm 4 Improve-Density(A,G, Γe)
Require:

User-Item rating matrix A.
Bipartite graph G = (V,E) = (R∪C ,E) of A.
GPES resultΓ e = {V1V2 ···Vk} of G.
Average density of diagonal blocks greater than ρ(A).

Ensure:

end for
Permute line l" to borders
V"i! ←V "i! −{ node(l")}
V"S ←V "S ∪{ node(l")}  node(l") denotes the node in
V"i! corresponding to line l"

15: end while
16: return {V"1V"2 ···V"k;V"S}

1: {V"1V"2 ···V"k;V"S}←{V 1V2 ···Vk;∅}
2: while ¯ρ(D1D2 ···D k) <ρ (A) do
l", i" ← 0, ¯ρ" ← 0
3:
4:
for each diagonal block Di do
5:
¯ρ ← !k
6:
!k
l" ← l, i" ← i, ¯ρ" ← ¯ρ

for each line l in Di do

j=1 area(Dj )−area(l(Di))

j=1 n(Dj )−n(l(Di))

if ¯ρ> ¯ρ" then

end if
end for

7:
8:
9:
10:
11:
12:
13:
14:

Note that, when looking for the line that improves the
average density the most, there is no need to check all of
the lines in each diagonal block in a real implementation.
In each diagonal block, we only need to check the line with
the minimum density restricted to it, namely the line that
contains the fewest non-zeros in it.

4.3

(A)BBDF-based Rating Prediction

A great advantage of the CF framework based on the ac-
curate or approximate BBDF structure is that any CF al-
gorithm can be used on a submatrix that is made up of
diagonal blocks and borders. In this paper, we do not pro-
pose new CF algorithms on (A)BBDF structures but instead
propose a general CF framework, which makes use of user-
item communities. By utilizing the community information,
the prediction accuracy tends to be improved. Furthermore,
conducting collaborative ﬁltering on smaller and denser sub-
matrices contributes to the scalability of CF algorithms.

The intuitive example shown in Figure 6 will be used to
introduce the framework. For each diagonal block, we re-
construct its corresponding community by combining it with
borders from diﬀerent levels. Speciﬁcally, we use dominant
users and items together with the corresponding super users
and items to make predictions. In Figure 6, three submatri-
ces are constructed, which correspond to the diagonal blocks
A, B and C. Note that, in the ABBDF structure, scattered
non-zeros in oﬀ-diagonal areas are ignored because they are
viewed as special interests or unprofessional ratings of users.
On each submatrix, any CF algorithm can be conducted
to make rating predictions. There could be more than one
prediction for user-item pairs from border crosses because
they are shared by diﬀerent submatrices. These predictions
are averaged as the ﬁnal prediction. It is a natural idea that
the predictions can be averaged with diﬀerent weights, but
in this paper, we take only the average value. The averaging
strategy could be investigated in future work.

(cid:1)(cid:1)

(cid:4)(cid:8)(cid:1)(cid:1)

(cid:2)(cid:1)
(cid:4)(cid:8)(cid:2)(cid:1)

(cid:4)(cid:8)(cid:2)(cid:1)
(cid:4)(cid:8)(cid:5)(cid:1)

(cid:4)(cid:8)(cid:1)(cid:1)

(cid:4)(cid:7)(cid:1)(cid:1)

(cid:4)(cid:7)(cid:2)(cid:1)

(cid:4)(cid:7)(cid:6)(cid:1)

(cid:3)(cid:1)
(cid:4)(cid:7)(cid:3)(cid:1)

(cid:4)(cid:7)(cid:1)(cid:1)

(cid:4)(cid:7)(cid:2)(cid:1)
(cid:4)(cid:7)(cid:6)(cid:1)
(cid:4)(cid:7)(cid:3)(cid:1)
(cid:4)(cid:7)(cid:5)(cid:1)

(a) BBDF matrix

(cid:1)(cid:1)

(cid:4)(cid:8)(cid:1)(cid:1)

(cid:4)(cid:7)(cid:1)(cid:1)

(cid:2)(cid:1) (cid:4)(cid:8)(cid:2)(cid:1)
(cid:4)(cid:8)(cid:2)(cid:1) (cid:4)(cid:8)(cid:5)(cid:1)
(cid:4)(cid:7)(cid:2)(cid:1) (cid:4)(cid:7)(cid:6)(cid:1)

(cid:4)(cid:7)(cid:2)(cid:1)
(cid:4)(cid:7)(cid:6)(cid:1)
(cid:4)(cid:7)(cid:5)(cid:1)

(cid:4)(cid:7)(cid:6)(cid:1)
(cid:4)(cid:7)(cid:5)(cid:1)

(cid:4)(cid:8)(cid:1)(cid:1) (cid:4)(cid:8)(cid:5)(cid:1)
(cid:4)(cid:7)(cid:1)(cid:1)
(cid:4)(cid:7)(cid:6)(cid:1)
(b) Submatrices extracted

(cid:3)(cid:1) (cid:4)(cid:7)(cid:3)(cid:1)
(cid:4)(cid:7)(cid:3)(cid:1) (cid:4)(cid:7)(cid:5)(cid:1)

Figure 6: A toy example for extracting communities

5. EXPERIMENTS
5.1 Dataset Description

We conducted a series of experiments on four real-world
datasets: MovieLens-100K, MovieLens-1M, Dianping and
Yahoo! Music to validate the eﬀectiveness of the proposed
framework. Among these datasets, MovieLens-100K and
MovieLens-1M are from the well-known MovieLens dataset.

Table 1: Statistics of the four datasets

#users
#items
#ratings
#ratings/user
#ratings/item
average density

943
1,682

ML-100K ML-1M Dianping Yahoo! Music
1,000,990
624,961
262,810,175
262.550
420.523
0.000421

6,040
3,952
100,000 1,000,209
165.598
106.045
253.089
59.453
0.0630
0.0419

11,857
22,365
510,551
43.059
22.828
0.00193

318Table 2: Community analysis for Approximate BBDF on Dianping when density requirement is 0.005

Community
City
#users
#restaurants
%accuracy

1
Chengdu
323
1189
89.6

4

3

2

5
Shenzhen Tianjin Beijing Nanjing
684
1327
91.6

2903
5011
94.4

288
1359
90.4

922
2548
92.6

7

6

8
Suzhou Hangzhou Guangzhou
845
1274
90.7

295
1309
89.2

262
1443
88.7

9
Shanghai
4531
4586
91.1

(a) BBDF ρ = 0.005

(b) BBDF ρ = 0.01

(c) ABBDF ρ = 0.005

(d) ABBDF ρ = 0.01

Figure 7: Accurate BBDF (BBDF) and Approximate BBDF (ABBDF) structures on Dianping dataset

Besides, we also collected a year’s data from a famous restau-
rant rating web site Dianping.com (http://www.dianping.com)
in China, and selected those users who made 20 or more rat-
ings. The ratings also range from 1 to 5 like the MovieLens
dataset. The Yahoo Music dataset [8] is from KDD Cup
2011, and its ratings range from 1 to 100. Statistics on
these four datasets are presented in Table 1.

These datasets are chosen because they have diﬀerent sizes
and densities. Additionally, two of them have more users
than items, and the other two are the opposite. We expect
to verify whether the framework works regardless of the size
or density of the matrix. A signiﬁcant diﬀerence between
Dianping and other frequently used datasets is that Dian-
ping is a location-based service in which the longitude and
latitude of each restaurant is recorded. By analyzing the
locations of user-item communities discovered by (A)BBDF
algorithms, we expect to obtain an intuitional observation
of their eﬀects.

5.2 Algorithms and Evaluation Metrics

Four popular CF algorithms were experimented on using
the framework. The User-based and Item-based CF algo-
rithms are famous memory based approaches, while SVD
and NMF are known to be famous matrix factorization ap-
proaches.

User-based: The Pearson correlation was used for user
similarities, as suggested in [29]. The neighborhood size is
k = 100.

Item-based: Adjusted cosine similarity was used because
it is reported to give the best performance in [31], and k =
100 is also used for neighborhood size.

SVD: We use the popular SVD prediction strategy pre-
sented in [16]. Here, the number of factors k is 100, and the
regularization coeﬃcient λ is 0.015.

NMF: The most commonly used non-negative matrix fac-
torization algorithm in [17] was used to make predictions,
and we also used k = 100 and λ = 0.015.

To make a comparison with the literature, we used the
Root Mean Square Error (RMSE) to measure the predic-
tion accuracy in this work. Five-fold cross validation was
conducted on the MovieLens and Dianping datasets, and
the average RMSE was calculated. For the Yahoo! Mu-
sic dataset, we used its training set and validation set for
training and evaluation, respectively.

s
k
c
o
B

l

 
l

a
n
o
g
a
D
#

i

s
k
c
o
B

l

 
l

a
n
o
g
a
D
#

i

30

25

20

15

10

5

 

0
0.06
30

25

20

15

10

5

 

0
0

Accurate BBDF
Approximate BBDF
MovieLens−100K

0.07

0.08

0.09

Density Requirement

0.1

Accurate BBDF
Approximate BBDF

Dianping

0.01

0.02

0.03

0.04

Density Requirement

s
k
c
o
B

l

 
l

a
n
o
g
a
D
#

i

s
k
c
o
B

l

 
l

a
n
o
g
a
D
#

i

35
30
25
20
15
10
5
0
0.04

 

60
50
40
30
20
10
0

 

 

0.11

 

0.05

Accurate BBDF
Approximate BBDF

MovieLens−1M

0.05

0.06

0.07

Density Requirement

0.08

Accurate BBDF
Approximate BBDF

Yahoo

1

2

4
Density Requirement

3

 

0.09

 

5
x 10−3

Figure 8: #communities v.s. density requirement

5.3 Community Analysis

The most important parameter in the density-based BBDF
and ABBDF permutation algorithms is the density require-
ment ρ. Low density requirements lead to fewer and larger
user-item communities, and high density requirements re-
sult in more and smaller communities, as shown in Figure
7, where ρ = 0.005 and ρ = 0.01 are applied to the accurate
and approximate BBDF algorithms on the Dianping dataset.
Note that the matrix is not as dense as it appears to be in
these ﬁgures; The appearance of density arises because more
than half a million points are restricted to a small canvas.

An appropriate density requirement is important. If the
density requirement is too low, then the user-item communi-
ties hidden in the original rating matrix cannot be extracted
properly and completely. However, if the density require-
ment is too high, then it will result in many small scattered
communities, which could lead to over-ﬁtting problems.

An appropriate density requirement gives reasonable and
meaningful communities. See the ABBDF structure in Fig-
ure 7(d), for example. Nine communities are extracted,
numbered 1 through 9, from the upper-left to bottom-right
corner. It is interesting to note that they represent nine main
cities in China. Table 2 presents these cities and shows how
high a percentage of restaurants in each community truly
belong to that corresponding city.

One can ﬁnd that communities 5, 6, 7 and 9 are highly re-
lated to each other by the dense pseudo-blank areas marked
by circles. By viewing the dense areas horizontally, we know

3190.94

0.93

0.92

0.91

0.9

0.89

E
S
M
R

0.88

 

0.06

 

User
Item
SVD
NMF

MovieLens−100K

0.07
0.09
Density Requirement

0.08

0.1

0.89

0.88

0.87

0.86

0.85

0.84

0.83

E
S
M
R

0.82

 

0.04

User
Item
SVD
NMF

MovieLens−1M

0.05

0.06

0.07

0.08

Density Requirement

 

0.94

0.92

0.9

0.88

0.86

0.84

0.82

E
S
M
R

0.09

0.8
0

 

 

Dianping

User

Item

SVD

NMF

0.01

0.02

0.03

0.04

Density Requirement

0.05

E
S
M
R

26

25

24

23

22

 

21
0

Yahoo!

User

Item

SVD

NMF

1

2

Density Requirement

3

 

4

5
x 10−3

(b) acc.BBDF ML-1M

(c) acc.BBDF Dianping

(d) acc.BBDF Yahoo!

(a) acc.BBDF ML-100K
0.94

 

E
S
M
R

0.93

0.92

0.91

0.9

0.89

0.88

 

0.06

MovieLens−100K

User

Item

SVD

NMF

0.07

0.08

0.09

Density Requirement

0.1

0.9

0.88

0.86

0.84

0.82

E
S
M
R

0.11

 

0.04

MovieLens−1M

User

Item

SVD

NMF

0.05

0.06

0.07

0.08

Density Requirement

 

0.09

E
S
M
R

0.94
0.92
0.9
0.88
0.86
0.84
0.82
0.8
0.78
0

 

 

Dianping

User

Item

SVD

NMF

0.01

0.02

0.03

0.04

0.05

Density Requirement

E
S
M
R

26

25

24

23

22

 

21
0

Yahoo!

User

Item

SVD

NMF

1

2

Density Requirement

3

 

4

5
x 10−3

(e) app.BBDF ML-100K

(f) app.BBDF ML-1M

(g) app.BBDF Dianping

(h) app.BBDF Yahoo!

Figure 9: RMSE on the four datasets based on accurate (acc.) and approximate (app.) BBDF structures

that users in one city can usually go to restaurants in an-
other city, and vertically we know that restaurants in the
other city can be frequently visited by users from the ﬁrst
city. These observations are reasonable in reality because
these four cities are geographically very close to each other,
as shown in Figure 10. Traﬃc among these cities is devel-
oped, and their business relationships are close. In fact, this
area is exactly the famous Yangtze River Delta of China.

Figure 8 shows the relationship between the number of
extracted communities and the density requirement on the
four datasets, respectively. For accurate BBDF, the num-
ber of communities rises ﬁrst, and then tends to be stable
after a certain density requirement is met because a diag-
onal block will not be permuted recursively if its average
density does not increase after graph partitioning. How-
ever, for approximate BBDF, the number of communities
increases consistently because it moves lines to borders to
increase the average density in such cases. This strategy
makes the algorithm more ﬂexible but could also lead to too
many small scattered communities if the density require-
ment is too high. The impact of the density requirement on
the prediction accuracy will be analyzed next.

5.4 Prediction Accuracy

Experimental results on four datasets show that the pro-
posed CF framework helps existing CF algorithms to im-
prove their accuracy in a large range of density requirements.
The experimental results on the RMSE versus the density
requirement is shown in Figure 9. Each sub-ﬁgure presents

Figure 10: Location of the four highly related cities.

the performance of all of the four CF algorithms on the cor-
responding dataset. Note that the beginning point of each
curve represents the base performance of the CF method on
the dataset, and the density requirement of this point is set
to the density of the whole rating matrix. As a result, points
on a curve below its beginning point mean an improvement
on the prediction accuracy, and vice versa.

We must note the fact that the very large number of users
and items in the Yahoo! Music dataset makes it unrealistic
for current hardware to conduct memory-based CF algo-
rithms. To the best of our knowledge, there is no report
of direct user-based or item-based collaborative ﬁltering on
this dataset. Strategies such as KNN with SVD features
[12] or parallelization [38] were attempted in KDD cup, but
these strategies would make the results incomparable with
other datasets. As a result, we did not perform KNN on the
whole dataset. However, we found that our CF framework
makes it possible to run KNN predictions on a standalone
machine when the number of communities is more than 27,
and experiments were performed in such cases.

Experimental results show that the proposed CF frame-
work on accurate BBDF beneﬁts user-based, SVD, and NMF
algorithms consistently on all of the four datasets. However,
mixed results were obtained on the item-based CF method.
On MovieLens-1M, Dianping and Yahoo! Music datasets,
its performance is slightly improved, but on the MovieLens-
100K dataset, its accuracy rises at ﬁrst and begins to drop
while the density requirement continues to rise. Further-
more, a negative eﬀect can even be introduced if the density
requirement is too high.

This eﬀect could be the reason that the item-based algo-
rithm utilizes historical ratings of a user, which is diﬀerent
from other CF algorithms that take advantage of neighbor-
hood relationships. A user’s historical ratings are reduced
in the BBDF framework, especially on small datasets, which
introduces bad predictions. However, it still beneﬁts from
BBDF structure given reasonable density requirements.

For approximate BBDF structure, prediction accuracy im-
proves at ﬁrst but tends to drop when the density require-
ment is too high, in almost all of the cases. The reason for
the performance improvement could be that approximate
BBDF plays a role in data denoising, and user-item commu-
nities help to extract professional ratings. However, small

320Table 3: Best RMSE of the CF framework based on Accurate (Acc.) and Approximate (App.) BBDF
structures on the four datasets and the corresponding density requirement ρ. The standard deviations are ≤
0.006 on MovieLens and DianPing dataset and ≤ 0.05 on Yahoo! Music dataset.

MovieLens-100K

MovieLens-1M

Dianping

Yahoo! Music

Method

RMSE ρ RMSE ρ RMSE RMSE ρ RMSE ρ RMSE RMSE ρ RMSE ρ RMSE RMSE ρ RMSE ρ

base Acc.BBDF App.BBDF base Acc.BBDF App.BBDF base Acc.BBDF App.BBDF base Acc.BBDF App.BBDF
RMSE
0.0045 24.443 0.0035 24.798
0.871 0.070 0.859 0.065 0.858
0.0030 24.002 0.0025 24.020
0.859 0.065 0.845 0.070 0.830 0.850 0.025 0.831 0.020 0.832 22.746 0.0020 22.469 0.0025 22.434
0.854 0.075 0.842 0.075 0.823 0.843 0.030 0.824 0.020 0.818 23.572 0.0030 23.223 0.0040 23.124

User-based 0.936 0.085 0.927 0.085 0.914 0.887 0.070 0.876 0.070 0.856 0.887 0.025 0.864 0.030 0.854
Item-based 0.924 0.080 0.915 0.080 0.913
0.925 0.015 0.911 0.025 0.911
0.913 0.085 0.902 0.090 0.895
0.909 0.085 0.896 0.090 0.893

SVD
NMF

-
-

scattered communities could give bad predictions because
of over-ﬁtting problems, which leads to a decrease in the
performance when high density requirements are used.

Table 3 presents the best performance of each CF method
on each dataset for accurate and approximate BBDF frame-
works. A bold number indicates an obvious improvement,
where the RMSE is reduced more than 0.02 on MovieLens
and Dianping or more than 0.4 on Yahoo! Music.

When calculating the average RMSE on each dataset, ﬁve-
fold cross-validation was conducted on MovieLens and Di-
anPing, and experiments were conducted ﬁve times on Ya-
hoo!Music. Standard deviations were ≤ 0.006 on MovieLens
and DianPing and were ≤ 0.05 on Yahoo! Music.
We see that both accurate and approximate BBDF bene-
ﬁts CF algorithms in the best cases, and approximate BBDF
tends to achieve better performance.

5.5 Scalability and Efﬁciency

Experiments were conducted on a linux server with 8 core
3.1GHz CPU and 64GB RAM. For both accurate and ap-
proximate BBDF algorithms on each dataset, we averaged
the computational time consumed under diﬀerent density
requirements, as shown in Table 4.

Table 4: Computational time of the BBDF and
ABBDF algorithms on the four datasets.

Dataset ML-100K ML-1M Dianping Yahoo!
42.6min
accBDF
appBDF
103.4min

85.6ms
521.8ms

21.2s
80.3s

1.61s
6.43s

Experiments show that the computational time of the
BBDF algorithms increases along with the scale of rating
matrices, but the time used for BBDF permutation is small
compared with the CF prediction algorithms. Moreover,
once BBDF structures have been constructed, they help to
decrease the total prediction time by conducting collabo-
rative ﬁltering on smaller submatrices, especially for user-
based and item-based methods. We calculated the average
speedups for each CF algorithm on each dataset, as shown
in Table 5, where speedup is deﬁned as:

Sp =

TCF

TBBDF + TBBDF CF

TCF is the time used by a CF prediction algorithm on the
whole matrix, TBBDF is the time of accurate or approximate
BBDF permutation algorithms, and TBBDF CF is the time
of CF prediction algorithms on (A)BBDF structures.

The experimental results show that in almost all of the
cases, (A)BBDF structures speed up rating prediction; the
speedup is obvious especially for nearest neighbor CF meth-
ods and large datasets.

Table 5: Speedups of conducting collaborative ﬁlter-
ing based on (A)BBDF structures on four datasets.

Dataset

User
Item
SVD
NMF

ML-100K
app.
acc.
1.25
1.28
1.19
1.15
1.10
1.11
1.02
1.07

ML-1M

acc.
1.24
1.21
1.16
1.20

app.
1.21
1.18
1.28
1.17

Dianping
app.
acc.
1.21
1.33
1.29
1.39
1.30
1.28
1.32
1.26

Yahoo!

acc.

app.

-
-

-
-

1.46
1.54

1.34
1.47

6. DISCUSSION

In practical real-world recommender systems, rating ma-
trices are usually changing continuously as new ratings are
made by users. However, (A)BBDF structures make it pos-
sible to re-predict the submatrices that are truly in need of
re-prediction, for example, those whose RMSE have reached
a criterion, rather than to re-predict the whole matrix, which
might further contribute to the scalability in real-world rec-
ommender systems.

The cold-start problem has long been an important is-
sue in the research of collaborative ﬁltering. By inserting a
new user or item into a proper community and making rec-
ommendations there, the framework could beneﬁt the cold-
start recommendation. Additionally, ABBDF structure dis-
tinguishes a user’s special interests from the general inter-
ests of his or her community, which could contribute to the
serendipity of the recommendations, and these issues will be
investigated in future work.

Although the (A)BBDF permutation algorithms have only
one tunable parameter density requirement ρ, it could be dif-
ﬁcult to determine a proper ρ given a new dataset in real
applications because too low or too high density require-
ments might both not give the best performance, which is
currently a shortcoming of the algorithms. Further work
will be performed to investigate the possibility of learning
proper density requirements automatically.

7. CONCLUSIONS

In this paper, we investigated the relationship between
(A)BBDF structures and community detection on user-item
bipartite graphs, and we proposed algorithms that, in fact,
need only one intuitional parameter density requirement to
permute a matrix into (A)BBDF structures. We further
proposed a general collaborative ﬁltering framework that is
based on (A)BBDF structures to make rating predictions.

Experimental results show that, by utilizing user-item com-
munities contained in these structures, the proposed frame-
work beneﬁts many CF algorithms improving their predic-
tion accuracies, and at the same time contributes to system
scalability, which means that (A)BBDF structures tend to
be a general and promising framework to improve the per-
formance of existing CF algorithms.

3218. ACKNOWLEDGEMENT

The authors thank the anonymous reviewers for their con-
structive reviews and suggestions. This work was supported
by Natural Science Foundation (60903107,61073071) and Na-
tional High Technology Research and Development (863)
Program (2011AA01A205) of China.

9. REFERENCES

[1] C. Aykanat, A. Pinar, and U. V. Catalyurek.
Permuting Sparse Rectangular Matrices into
Block-Diagonal From. SISC, 2004.

[2] R. M. Bell and Y. Koren. Scalable Collaborative

Filtering with Jointly Derived Neighborhood
Interpolation Weights. Proc. ICDM, 2007.

[3] E. Boman and M. Wolf. A Nested Dissection approach

to Sparse Matrix Partitioning for Parallel
Computations. Proc. AMM, 2007.

[4] M. Brand. Fast online SVD revisions for lightweight

recommender systems. Proc. SIAM SDM, 2003.

[5] T. N. Bui and C. Jones. Finding Good Approximate

Vertex and Edge Partitions is NP-hard. Inform.
Process. Lett., 1992.

[6] J. Chen and Y. Saad. Dense Subgraph Extraction with

Application to Community Detection. TKDE, 2012.

[7] I. S. Dhillon, S. Mallela, and D. S. Modha.

Information Theoretic Co-clustering. Proc. SIGKDD,
pages 89–98, 2003.

[8] G. Dror, N. Koenigstein, Y. Koren, and M. Weimer.

The Yahoo! Music Dataset and KDD-Cup’11.
KDDCUP, 2011.

[9] S. Fortunato. Community Detection in Graphs.

Physics Reports, 486:75–174, 2010.

[10] R. Gemulla, E. Nijkamp, P. J. Haas, and Y. Sismanis.

Large-scale Matrix Factorization with Distributed
Stochastic Gradient Descent. KDD, 2011.

[11] T. George and S. Merugu. A Scalable Collaborative

Filtering Framework based on Co-clustering. Proc.
ICDM, 2005.

[12] M. Jahrer and A. Toscher. Collaborative Filtering

Ensemble. KDDCUP, 2011.

[13] G. Karypis. Metis-A Software Package for Partitioning

Unstructured Graphs, Meshes, and Computing
Fill-Reducing Orderings of Sparse Matrices-Version
5.0. University of Minnesota, 2011.

[14] G. Karypis and V. Kumar. A Fast and High Quality
Multilevel Scheme for Partitioning Irregular Graphs.
SISC, 1998.

[15] J. Kim, I. Hwang, Y. H. Kim, and B. R. Moon.
Genetic Approaches for Graph Partitioning: A
Survey. Proc. CECCO, pages 473–480, 2011.

[16] Y. Koren, R. Bell, and C. Volinsky. Matrix

Factorization Techniques for Recommender Systems.
Computer, 42:30–37, 2009.

[17] D. D. Lee and H. S. Seung. Algorithms for

Non-negative Matrix Factorization. NIPS, 2001.

[18] K. W. Leung, D. L. Lee, and W. Lee. CLR: A

Collaborative Location Recommendation Framework
based on Co-Clustering. Proc. SIGIR, 2011.

[19] T. Li, C. Gao, and J. Du. A NMF-based

Privacy-Preserving Recommendation Algorithm. Proc.
ICISE, 2009.

[20] W. Lin, X. Kong, P. S. Yu, Q. Wu, Y. Jia, and C. Li.

Community Detection in Incomplete Information
Networks. Proc. WWW, pages 341–349, 2012.
[21] C. Liu, H. Yang, J. Fan, L. He, and Y. Wang.

Distributed Nonnegative Matrix Factorization for
Web-scale Dyadic Data Analysis on MapReduce. Proc.
WWW, pages 681–690, 2010.

[22] J. Liu, M. Z. Q. Chen, J. Chen, F. Deng, H. Zhang,

Z. Zhang, and T. Zhou. Recent Advances in Personal
Recommender Systems. Jour. Info. and Sys. Sci.,
5:230–247, 2009.

[23] F. Luo, J. Z. Wang, and E. Promislow. Exploring

Local Community Structures in Large Networks. Proc.
WI, 2006.

[24] T. Nakahara and H. Morita. Recommender System for
Music CDs Using a Graph Partitioning Method. Proc.
KES, 2009.

[25] J. Noel, S. Sanner, K. Tran, P. Christen, and L. Xie.

New Objective Functions for Social Collaborative
Filtering. Proc. WWW, pages 859–868, 2012.

[26] M. O’Connor and J. Herlocker. Clustering Items for

Collaborative Filtering. Proc. SIGIR Workshop, 1999.
[27] S. Oyanagi, K. Kubota, and A. Nakase. Application of

Matrix Clustering to Web Log Analysis and Access
Prediction. Proc. WEBKDD, pages 13–21, 2001.

[28] M. J. Pazzani and D. Billsus. Content-Based

Recommendation Systems. The Adaptive Web LNCS,
pages 325–341, 2007.

[29] P. Resnick, N. Iacovou, M. Suchak, P. Bergstrom, and

J. Riedl. GroupLens: An Open Architecture for
Collaborative Filtering of Netnews. CSCW, 1994.
[30] P. Sanders and C. Schulz. Engineering Multilevel

Graph Partitioning Algorithms. ESA, 2011.

[31] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl.

Item-Based Collaborative Filtering Recommendation
Algorithms. Proc. WWW, pages 285–295, 2001.

[32] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl.

Incremental Singular Value Decomposition Algorithms
for Highly Scalable Recommender Systems. Proc.
ICCIT, 2002.

[33] B. M. Sarwar, G. Karypis, J. A. Konstan, and J. T.

Riedl. Application of Dimensionality Reduction in
Recommender Systems - a case study. WebKDD, 2000.

[34] B. Savas and I. S. Dhillon. Clustered Low Rank
Approximation of Graphs in Information Science
Applications. Proc. SIAM SDM, pages 164–175, 2011.

[35] B. Savas and I. S. Dhillon. Clustered Low Rank
Approximation of Graphs in Information Science
Applications. Proc. SIAM SDM, pages 164–175, 2011.

[36] F. Wang, T. Li, X. Wang, S. Zhu, and C. Ding.

Community Discovery using Nonnegative Matrix
Factorization. Journal of DMKD, 22, 2011.

[37] Q. Wang, J. Xu, H. Li, and N. Craswell. Regularized

Latent Sematic Indexing. Proc. SIGIR, 2011.

[38] Y. Wu, Q. Yan, D. Bickson, et al. Eﬃcient Multicore

Collaborative Filtering. KDDCUP, 2011.

[39] B. Xu, J. Bu, and C. Chen. An Exploration of

Improving Collaborative Recommender Systems via
User-Item Subgroups. WWW, pages 21–30, 2012.

[40] S. Zhang, W. Wang, J. Ford, and F. Makedon.

Learning from Incomplite Ratings Using Non-negative
Matrix Factorization. Proc. SIAM SDM, 2006.

322